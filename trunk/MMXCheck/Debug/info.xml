<?xml version="1.0" encoding="gb2312" standalone="yes" ?>
<config Author="angus">
    <!-- \lj 指令是用于编辑框中换行的，ALJ_MAX的count数量一定要小于等于后续的数量-->
    <ALJ_MAX count="47"/>
    <ALJ_0 name="movq" func="从mmx寄存器传输64位(4字)整数" intro="数据传输指令\lj\lj用法：movq dest,src\lj说明：dest为MMX寄存器/通用寄存器，src为MMX寄存器/通用寄存器。其作用是将src的64位传送到dest。"/>
    <ALJ_1 name="movd" func="从mmx寄存器传输32位(双字)整数" intro="数据传输指令\lj\lj用法：movd dest,src\lj说明：dest为MMX寄存器/通用寄存器/存储器，src为MMX寄存器/通用寄存器/存储器。其作用是将src中的32位传送到dest的低32位并置dest的高32位零。"/>	
    <ALJ_2 name="packsswb" func="按有符号饱和压缩字成字节" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>
    <ALJ_3 name="packssdw" func="按有符号饱和压缩双字成字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>	
    <ALJ_4 name="packuswb" func="按无符号饱和压缩字成字节" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>
    <ALJ_5 name="packsshbw" func="扩展高位字节成字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>
    <ALJ_6 name="packsshwd" func="扩展高位字成双字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>	
    <ALJ_7 name="packsshdq" func="扩展高位双字成4字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>
    <ALJ_8 name="packsslbw" func="扩展低位字节成字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>
    <ALJ_9 name="packsslwd" func="扩展低位字成双字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>	
    <ALJ_10 name="packssldq" func="扩展低位双字成4字" intro="数据打包转换指令\lj\lj说明：每个打包指令前面的P都是Packet的缩写，就是说每个寄存器里的数据都是个数据包，而不是一个数据。那么这些指令就是把这些数据打包或拆包（我不知该怎么下这个操作的定义）用的。"/>
    <ALJ_11 name="paddb" func="环绕加字节" intro="算术运算指令\lj\lj说明：这条指令和普通的算术指令没什么运算规则上的区别，只不过是一个指令处理多个数据而已！"/>
    <ALJ_12 name="paddw" func="环绕加字" intro="算术运算指令\lj\lj说明：这条指令和普通的算术指令没什么运算规则上的区别，只不过是一个指令处理多个数据而已！"/>
    <ALJ_13 name="paddd" func="环绕加双字" intro="算术运算指令\lj\lj说明：这条指令和普通的算术指令没什么运算规则上的区别，只不过是一个指令处理多个数据而已！"/>
    <ALJ_14 name="paddsb" func="有符号饱和加字节" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_15 name="paddsw" func="有符号饱和加字" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_16 name="paddusb" func="无符号饱和加字节" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_17 name="paddusw" func="无符号饱和加字" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_18 name="psubb" func="环绕减字节" intro="算术运算指令\lj\lj说明：这条指令和普通的算术指令没什么运算规则上的区别，只不过是一个指令处理多个数据而已！"/>
    <ALJ_19 name="psubw" func="环绕减字" intro="算术运算指令\lj\lj说明：这条指令和普通的算术指令没什么运算规则上的区别，只不过是一个指令处理多个数据而已！"/>
    <ALJ_20 name="psubd" func="环绕减双字" intro="算术运算指令\lj\lj说明：这条指令和普通的算术指令没什么运算规则上的区别，只不过是一个指令处理多个数据而已！"/>
    <ALJ_21 name="psubsb" func="有符号饱和减字节" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_22 name="psubsw" func="有符号饱和减字" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_23 name="psubusb" func="无符号饱和减字节" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_24 name="psubusw" func="无符号饱和减字" intro="算术运算指令\lj\lj说明：当运算结果大于一个上限或小于一个下限时，结果就等于一个上限或下限。例如：byte运算，最大值是255。0xF1+0x35应该是等于0x26，但由于结果大于255，所以结果被饱和为0XFF。"/>
    <ALJ_25 name="pmulhw" func="紧缩字乘后取高位" intro="算术运算指令\lj\lj本来两个word相乘，结果是个dword。不过Intel为了保持数据的一致性，就搞了这么的方法，一次给你高位，再次给你低位。假如我们要判断两数是否同号。只要乘完取高位就行了，低位用不上，所以虽然浪费了点cpu时间，到也不是一个破指令！"/>
    <ALJ_26 name="pmullw" func="紧缩字乘后取低位" intro="算术运算指令\lj\lj本来两个word相乘，结果是个dword。不过Intel为了保持数据的一致性，就搞了这么的方法，一次给你高位，再次给你低位。假如我们要判断两数是否同号。只要乘完取高位就行了，低位用不上，所以虽然浪费了点cpu时间，到也不是一个破指令！"/>
    <ALJ_27 name="pmaddwd" func="紧缩字乘积相加" intro="算术运算指令\lj\lj说明：向量点乘运算，学过高数的人应该都清楚！"/>
    <ALJ_28 name="pcmpeqb" func="紧缩比较字节是否相等" intro="比较运算指令\lj\lj说明：这条指令用在字符串的快速比较，据Intel官方说速度提高50%！我的个神."/>
    <ALJ_29 name="pcmpeqw" func="紧缩比较字是否相等" intro="比较运算指令\lj\lj说明：这条指令用在字符串的快速比较，据Intel官方说速度提高50%！我的个神."/>
    <ALJ_30 name="pcmpeqd" func="紧缩比较双字是否相等" intro="比较运算指令\lj\lj说明：这条指令用在字符串的快速比较，据Intel官方说速度提高50%！我的个神."/>
    <ALJ_31 name="pcmpgtb" func="紧缩比较字节是否大于" intro="比较运算指令\lj\lj说明：这条指令用在字符串的快速比较，据Intel官方说速度提高50%！我的个神."/>
    <ALJ_32 name="pcmpgtw" func="紧缩比较字是否大于" intro="比较运算指令\lj\lj说明：这条指令用在字符串的快速比较，据Intel官方说速度提高50%！我的个神."/>
    <ALJ_33 name="pcmpgtd" func="紧缩比较双字是否大于" intro="比较运算指令\lj\lj说明：这条指令用在字符串的快速比较，据Intel官方说速度提高50%！我的个神."/>
    <ALJ_34 name="pand" func="紧缩逻辑与" intro="逻辑运算指令\lj\lj说明：该指令与8086汇编里的一样，只是把它换成32位的而已！"/>
    <ALJ_35 name="pandn" func="紧缩逻辑与非" intro="逻辑运算指令\lj\lj说明：该指令与8086汇编里的一样，只是把它换成32位的而已！\lj\lj备注：这是取非后再按位与(dest = (~dest) & src)，两个8086汇编指令合到一个指令中了。"/>
    <ALJ_36 name="por" func="紧缩逻辑或" intro="逻辑运算指令\lj\lj说明：该指令与8086汇编里的一样，只是把它换成32位的而已！"/>
    <ALJ_37 name="pxor" func="紧缩逻辑异或" intro="逻辑运算指令\lj\lj说明：该指令与8086汇编里的一样，只是把它换成32位的而已！"/>
    <ALJ_38 name="psllw" func="紧缩逻辑左移字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_39 name="pslld" func="紧缩逻辑左移双字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_40 name="psllq" func="紧缩逻辑左移4字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_41 name="psrlw" func="紧缩逻辑右移字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_42 name="psrld" func="紧缩逻辑右移双字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_43 name="psrlq" func="紧缩逻辑右移4字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_44 name="psraw" func="紧缩算术右移字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>
    <ALJ_45 name="psrad" func="紧缩算数右移双字" intro="位移运算指令\lj\lj说明：跟8086汇编指令没什么区别，唯一不一样的就是没有byte的位移运算，不晓得为什么！"/>	
    <ALJ_46 name="emms" func="清除mmx状态" intro="状态清除指令\lj\lj说明：由于执行MMX指令时占用了浮点运算单元，使用完MMX指令后要记住执行这条指令已释放浮点运算单元。！"/>
</config>
